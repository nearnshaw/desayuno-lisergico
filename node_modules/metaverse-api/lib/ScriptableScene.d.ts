import { Script, EntityController, ISimplifiedNode, EventSubscriber, IEventNames, IEvents } from '.';
export declare const defer: any;
export declare function recursiveRender(tree: ISimplifiedNode): ISimplifiedNode | null;
export interface ScriptableScene<Props, State> {
    props: Props;
    state: State;
    /**
     * Called to determine whether the change in props and state should trigger a re-render.
     *
     * If false is returned, `ScriptableScene#render`, and `sceneDidUpdate` will not be called.
     */
    shouldSceneUpdate?(nextProps: Props, nextState: State): Promise<boolean> | boolean;
    /**
     * Called immediately before a scene is destroyed. Perform any necessary cleanup in this method, such as
     * cancelled network requests, or cleaning up any elements created in `sceneDidMount`.
     */
    sceneWillUnmount?(): Promise<void> | void;
    /**
     * Called immediately after a compoment is mounted. Setting state here will trigger re-rendering.
     */
    sceneDidMount?(): Promise<void> | void;
    /**
     * Called immediately after updating occurs. Not called for the initial render.
     */
    sceneDidUpdate?(prevProps: Readonly<Props>, prevState: Readonly<State>): Promise<void> | void;
}
/**
 * Base Scene class.
 * Provides `setState()` and `forceUpdate()`, which trigger rendering.
 * @public
 *
 * @example
 * class MyFoo extends ScriptableScene {
 *   async render() {
 *     return <sphere />;
 *   }
 * }
 */
export declare abstract class ScriptableScene<Props = {}, State = {}> extends Script {
    entityController: EntityController;
    eventSubscriber: EventSubscriber;
    _dirty: boolean;
    prevProps: Props | null;
    prevState: State | null;
    _component: ISimplifiedNode | null;
    state: State;
    connectionFuture: import("./utils/future").IFuture<Script>;
    props: Props;
    /**
     * Update scene state by copying properties from `state` to `this.state`.
     * @param {object} state A hash of state properties to update with new values
     */
    setState(state: Partial<State> | ((state: State, props: Props) => Partial<State>)): void;
    /**
     * Immediately perform a synchronous re-render of the component.
     */
    forceUpdate(): void;
    /**
     * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
     * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
     * @param {object} props    Props (eg: JSX attributes) received from parent element/component
     * @param {object} state    The component's current state
     */
    abstract render(props: Props, state: State): Promise<ISimplifiedNode>;
    /**
     * It makes a subscription to remote events, those events occur in the context of the game and are sent thru the wire
     * protocol.
     *
     * @param event name of the remote event to listen
     * @param handler an async
     */
    subscribeTo<T extends IEventNames>(event: T, handler: (data: IEvents[T]) => void | Promise<void>): void;
    systemDidEnable(): Promise<void>;
}
