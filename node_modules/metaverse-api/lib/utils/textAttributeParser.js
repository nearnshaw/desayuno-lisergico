"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function parseBool(val) {
    if (val === 'true' || val === 'false') {
        return val === 'true' ? true : false;
    }
    else {
        throw new Error(`Invalid boolean: ${val}. Booleans must be true or false.`);
    }
}
/**
 * parses a triplet of numbers like "0 1 2" into a vector-like object {x:0,y:1,z:2}
 */
function parseVector3(value) {
    if (typeof value !== 'string' || value.trim().length === 0) {
        throw new Error('Expected Vector3, got: ' + JSON.stringify(value));
    }
    const parts = value.split(/\s+/);
    const vector = { x: parseFloat(parts[0]), y: parseFloat(parts[1]), z: parseFloat(parts[2]) };
    if (isFinite(vector.x) && isFinite(vector.y) && isFinite(vector.z)) {
        return vector;
    }
    else {
        throw new Error(`Invalid Vector3: ${vector.x},${vector.y},${vector.z}. From ${JSON.stringify(value)}`);
    }
}
/**
 * Parses a "key:value;key2:value2" string into a map.
 */
function parseStyle(style) {
    const dict = {};
    style.split(/;+/g).forEach(pair => {
        const parts = pair.split(':', 2);
        const key = parts[0];
        const value = parts.length === 1 ? '' : parts[1];
        if (key.length && value.length) {
            const trimmedKey = key.trim();
            const trimmedValue = value.trim();
            dict[trimmedKey] = trimmedValue;
        }
    });
    return dict;
}
/**
 * Parses a string to milliseconds.
 * @param time 1s or 1000, .5s or 500
 */
function parseTime(time) {
    if (isFinite(time))
        return parseFloat(time);
    if (time
        .toString()
        .trim()
        .endsWith('s')) {
        return parseFloat(time.replace('s', '')) * 1000;
    }
    return parseFloat(time);
}
/**
 * Receives a transition with the format
 * Transition = component duration timing? delay?
 * Transitions = Transition [, Transition]*
 * @param val
 */
function parseTransitions(val) {
    const transitionDefiniions = val.split(/\s*,\s*/);
    const coso = transitionDefiniions.reduce((acc, definition) => {
        const parts = definition.split(/\s+/);
        const component = parts[0];
        return Object.assign({}, acc, { [component]: {
                duration: parseTime(parts[1]),
                timing: parts[2] || 'linear',
                delay: parts[3] ? parseTime(parts[3]) : 0
            } });
    }, {});
    return coso;
}
const parserMappings = {
    position: parseVector3,
    rotation: parseVector3,
    scale: parseVector3,
    visible: parseBool,
    width: parseFloat,
    // material: parseStyle,
    sound: parseStyle,
    transition: parseTransitions,
    skeletalAnimation: () => []
};
function camelCase(name) {
    return name.replace(/(?:-([a-z]))/g, function (whole, part) {
        return part.toUpperCase();
    });
}
function processAttributes(attrs, nodeName) {
    const ret = {};
    for (let i in attrs) {
        const camelCasedName = camelCase(i);
        if (i in parserMappings && typeof attrs[i] === 'string') {
            try {
                ret[camelCasedName] = parserMappings[i](attrs[i]);
            }
            catch (e) {
                // tslint:disable-next-line:no-console
                console.error(`Error parsing HTML attribute: ${i} in node ${nodeName}`, e);
            }
        }
        else {
            ret[camelCasedName] = attrs[i];
        }
    }
    return ret;
}
function processSimplifiedNode(node) {
    return Object.assign({}, node, { attrs: processAttributes(node.attrs, node.tag), children: (node.children && node.children.map(processSimplifiedNode)) || [] });
}
exports.processSimplifiedNode = processSimplifiedNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dEF0dHJpYnV0ZVBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy90ZXh0QXR0cmlidXRlUGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsbUJBQW1CLEdBQVc7SUFDNUIsSUFBSSxHQUFHLEtBQUssTUFBTSxJQUFJLEdBQUcsS0FBSyxPQUFPLEVBQUU7UUFDckMsT0FBTyxHQUFHLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQTtLQUNyQztTQUFNO1FBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsR0FBRyxtQ0FBbUMsQ0FBQyxDQUFBO0tBQzVFO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsc0JBQXNCLEtBQW1CO0lBQ3ZDLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQzFELE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO0tBQ25FO0lBRUQsTUFBTSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNoQyxNQUFNLE1BQU0sR0FBcUIsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFBO0lBRTlHLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFD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QUMsUUFBUSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUMsSUFBSSxFQUFFLElBQzVFO0FBQ0gsQ0FBQztBQU5ELHNEQU1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yM0NvbXBvbmVudCwgSVNpbXBsaWZpZWROb2RlLCBUcmFuc2l0aW9uVmFsdWUgfSBmcm9tICcuLidcblxuZnVuY3Rpb24gcGFyc2VCb29sKHZhbDogc3RyaW5nKSB7XG4gIGlmICh2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gdmFsID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYm9vbGVhbjogJHt2YWx9LiBCb29sZWFucyBtdXN0IGJlIHRydWUgb3IgZmFsc2UuYClcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlcyBhIHRyaXBsZXQgb2YgbnVtYmVycyBsaWtlIFwiMCAxIDJcIiBpbnRvIGEgdmVjdG9yLWxpa2Ugb2JqZWN0IHt4OjAseToxLHo6Mn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWZWN0b3IzKHZhbHVlOiBzdHJpbmcgfCBhbnkpOiBWZWN0b3IzQ29tcG9uZW50IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVmVjdG9yMywgZ290OiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICB9XG5cbiAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pXG4gIGNvbnN0IHZlY3RvcjogVmVjdG9yM0NvbXBvbmVudCA9IHsgeDogcGFyc2VGbG9hdChwYXJ0c1swXSksIHk6IHBhcnNlRmxvYXQocGFydHNbMV0pLCB6OiBwYXJzZUZsb2F0KHBhcnRzWzJdKSB9XG5cbiAgaWYgKGlzRmluaXRlKHZlY3Rvci54KSAmJiBpc0Zpbml0ZSh2ZWN0b3IueSkgJiYgaXNGaW5pdGUodmVjdG9yLnopKSB7XG4gICAgcmV0dXJuIHZlY3RvclxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBWZWN0b3IzOiAke3ZlY3Rvci54fSwke3ZlY3Rvci55fSwke3ZlY3Rvci56fS4gRnJvbSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICB9XG59XG4vKipcbiAqIFBhcnNlcyBhIFwia2V5OnZhbHVlO2tleTI6dmFsdWUyXCIgc3RyaW5nIGludG8gYSBtYXAuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGU6IHN0cmluZykge1xuICBjb25zdCBkaWN0OiBhbnkgPSB7fVxuICBzdHlsZS5zcGxpdCgvOysvZykuZm9yRWFjaChwYWlyID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhaXIuc3BsaXQoJzonLCAyKVxuICAgIGNvbnN0IGtleSA9IHBhcnRzWzBdXG4gICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5sZW5ndGggPT09IDEgPyAnJyA6IHBhcnRzWzFdXG5cbiAgICBpZiAoa2V5Lmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWRLZXkgPSBrZXkudHJpbSgpXG4gICAgICBjb25zdCB0cmltbWVkVmFsdWUgPSB2YWx1ZS50cmltKClcbiAgICAgIGRpY3RbdHJpbW1lZEtleV0gPSB0cmltbWVkVmFsdWVcbiAgICB9XG4gIH0pXG4gIHJldHVybiBkaWN0XG59XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyB0byBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0gdGltZSAxcyBvciAxMDAwLCAuNXMgb3IgNTAwXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGltZSh0aW1lOiBhbnkpIHtcbiAgaWYgKGlzRmluaXRlKHRpbWUpKSByZXR1cm4gcGFyc2VGbG9hdCh0aW1lKVxuICBpZiAoXG4gICAgdGltZVxuICAgICAgLnRvU3RyaW5nKClcbiAgICAgIC50cmltKClcbiAgICAgIC5lbmRzV2l0aCgncycpXG4gICkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRpbWUucmVwbGFjZSgncycsICcnKSkgKiAxMDAwXG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQodGltZSlcbn1cblxuLyoqXG4gKiBSZWNlaXZlcyBhIHRyYW5zaXRpb24gd2l0aCB0aGUgZm9ybWF0XG4gKiBUcmFuc2l0aW9uID0gY29tcG9uZW50IGR1cmF0aW9uIHRpbWluZz8gZGVsYXk/XG4gKiBUcmFuc2l0aW9ucyA9IFRyYW5zaXRpb24gWywgVHJhbnNpdGlvbl0qXG4gKiBAcGFyYW0gdmFsXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHJhbnNpdGlvbnModmFsOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IFRyYW5zaXRpb25WYWx1ZSB9IHtcbiAgY29uc3QgdHJhbnNpdGlvbkRlZmluaWlvbnMgPSB2YWwuc3BsaXQoL1xccyosXFxzKi8pXG4gIGNvbnN0IGNvc28gPSB0cmFuc2l0aW9uRGVmaW5paW9ucy5yZWR1Y2UoKGFjYywgZGVmaW5pdGlvbikgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gZGVmaW5pdGlvbi5zcGxpdCgvXFxzKy8pXG4gICAgY29uc3QgY29tcG9uZW50ID0gcGFydHNbMF1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2NvbXBvbmVudF06IHtcbiAgICAgICAgZHVyYXRpb246IHBhcnNlVGltZShwYXJ0c1sxXSksXG4gICAgICAgIHRpbWluZzogcGFydHNbMl0gfHwgJ2xpbmVhcicsXG4gICAgICAgIGRlbGF5OiBwYXJ0c1szXSA/IHBhcnNlVGltZShwYXJ0c1szXSkgOiAwXG4gICAgICB9XG4gICAgfVxuICB9LCB7fSlcblxuICByZXR1cm4gY29zb1xufVxuXG5jb25zdCBwYXJzZXJNYXBwaW5ncyA9IHtcbiAgcG9zaXRpb246IHBhcnNlVmVjdG9yMyxcbiAgcm90YXRpb246IHBhcnNlVmVjdG9yMyxcbiAgc2NhbGU6IHBhcnNlVmVjdG9yMyxcbiAgdmlzaWJsZTogcGFyc2VCb29sLFxuICB3aWR0aDogcGFyc2VGbG9hdCxcbiAgLy8gbWF0ZXJpYWw6IHBhcnNlU3R5bGUsXG4gIHNvdW5kOiBwYXJzZVN0eWxlLFxuICB0cmFuc2l0aW9uOiBwYXJzZVRyYW5zaXRpb25zLFxuICBza2VsZXRhbEFuaW1hdGlvbjogKCkgPT4gW11cbn1cblxuZnVuY3Rpb24gY2FtZWxDYXNlKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC8oPzotKFthLXpdKSkvZywgZnVuY3Rpb24od2hvbGUsIHBhcnQpIHtcbiAgICByZXR1cm4gcGFydC50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRyaWJ1dGVzKGF0dHJzOiBhbnksIG5vZGVOYW1lOiBzdHJpbmcpIHtcbiAgY29uc3QgcmV0OiBhbnkgPSB7fVxuXG4gIGZvciAobGV0IGkgaW4gYXR0cnMpIHtcbiAgICBjb25zdCBjYW1lbENhc2VkTmFtZSA9IGNhbWVsQ2FzZShpKVxuICAgIGlmIChpIGluIHBhcnNlck1hcHBpbmdzICYmIHR5cGVvZiBhdHRyc1tpXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFtjYW1lbENhc2VkTmFtZV0gPSAocGFyc2VyTWFwcGluZ3MgYXMgYW55KVtpXShhdHRyc1tpXSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcGFyc2luZyBIVE1MIGF0dHJpYnV0ZTogJHtpfSBpbiBub2RlICR7bm9kZU5hbWV9YCwgZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W2NhbWVsQ2FzZWROYW1lXSA9IGF0dHJzW2ldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1NpbXBsaWZpZWROb2RlKG5vZGU6IElTaW1wbGlmaWVkTm9kZSk6IElTaW1wbGlmaWVkTm9kZSB7XG4gIHJldHVybiB7XG4gICAgLi4ubm9kZSxcbiAgICBhdHRyczogcHJvY2Vzc0F0dHJpYnV0ZXMobm9kZS5hdHRycywgbm9kZS50YWcpLFxuICAgIGNoaWxkcmVuOiAobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLm1hcChwcm9jZXNzU2ltcGxpZmllZE5vZGUpKSB8fCBbXVxuICB9XG59XG4iXX0=