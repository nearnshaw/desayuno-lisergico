export declare type INotification = {
    method: string;
    params?: any;
    jsonrpc: '2.0';
};
export declare type IRequest = INotification & {
    id: number;
};
export declare type IResponse = {
    id: number;
    result?: any;
    error?: IError;
    jsonrpc: '2.0';
};
export declare type IError = {
    code: ErrorCode;
    message: string;
    data?: any;
};
export declare const enum ErrorCode {
    ParseError = -32700,
    InvalidRequest = -32600,
    MethodNotFound = -32601,
    InvalidParams = 32602,
    InternalError = -32603
}
export declare type PromiseOrNot<T> = Promise<T> | T;
export declare type Resolvable<T = any> = {
    resolve(arg: T): void;
    reject(arg: Error): void;
};
export declare type ILogOpts = {
    logConsole?: boolean;
};
export declare type IClient = {
    call(method: string, params: any): Promise<any>;
    on(method: string, handler: (params: any) => void): void;
    notify(method: string, params?: any): void;
};
export declare type IClientOpts = ILogOpts;
export declare type IServer = {
    expose(method: string, handler: (params: any) => Promise<any>): void;
    on(method: string, handler: (params: any) => void): void;
    notify(method: string, params?: any): void;
};
export declare type IServerOpts = ILogOpts;
export interface ScriptingTransport {
    allowBinary?: boolean;
    sendMessage(message: string | Uint8Array): void;
    onConnect?(callback: () => void): void;
    onMessage(callback: (message: string | Uint8Array) => void): void;
    onError?(callback: (e: Error) => void): void;
    onClose?(callback: () => void): void;
    close(): void;
}
