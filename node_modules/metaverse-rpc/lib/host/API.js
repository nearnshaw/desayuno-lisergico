const hasSymbol = typeof Symbol === 'function' && Symbol.for;
const exposedMethodSymbol = hasSymbol ? Symbol('exposedMethod') : 0xfea1;
export function exposeMethod(target, propertyKey, descriptor) {
    getExposedMethods(target).add(propertyKey);
}
export function getExposedMethods(instance) {
    const instanceAny = instance;
    instanceAny[exposedMethodSymbol] = instanceAny[exposedMethodSymbol] || new Set();
    return instanceAny[exposedMethodSymbol];
}
export function rateLimit(interval = 100) {
    return function (target, propertyKey, descriptor) {
        const originalValue = descriptor.value;
        let lastCall = performance.now();
        return Object.assign({}, descriptor, { value: function () {
                const now = performance.now();
                if (now - lastCall < interval) {
                    return Promise.reject(new Error('Rate limit exceeded'));
                }
                lastCall = now;
                return originalValue.apply(this, arguments);
            } });
    };
}
export function throttle(callLimit, interval = 100) {
    return function (target, propertyKey, descriptor) {
        const originalValue = descriptor.value;
        let initTime = performance.now();
        let calls = 0;
        return Object.assign({}, descriptor, { value: function () {
                const now = performance.now();
                if (now - initTime >= interval) {
                    calls = 0;
                    initTime = now;
                }
                if (calls >= callLimit) {
                    return Promise.reject(new Error('Throttling â€“ Maximum rate exceeded'));
                }
                calls++;
                return originalValue.apply(this, arguments);
            } });
    };
}
export class API {
    constructor(options) {
        this.options = options;
        for (let methodName of getExposedMethods(this)) {
            const theMethod = this[methodName];
            if (typeof theMethod === 'function') {
                if (typeof methodName === 'string') {
                    this.options.expose(methodName, theMethod.bind(this));
                }
            }
        }
    }
    static factory(ctor, options) {
        return new ctor(options);
    }
}
API.expose = exposeMethod;
export class SubscribableAPI extends API {
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQVBJLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hvc3QvQVBJLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUtBLE1BQU0sU0FBUyxHQUFHLE9BQU8sTUFBTSxLQUFLLFVBQVUsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFBO0FBRTVELE1BQU0sbUJBQW1CLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQTtBQUV4RSxNQUFNLHVCQUNKLE1BQVMsRUFDVCxXQUFvQixFQUNwQixVQUFvRDtJQUVwRCxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUE7QUFDNUMsQ0FBQztBQUVELE1BQU0sNEJBQTJDLFFBQVc7SUFDMUQsTUFBTSxXQUFXLEdBQVEsUUFBUSxDQUFBO0lBQ2pDLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUE7SUFDaEYsT0FBTyxXQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtBQUN6QyxDQUFDO0FBRUQsTUFBTSxvQkFBdUIsV0FBbUIsR0FBRztJQUNqRCxPQUFPLFVBQ0wsTUFBUyxFQUNULFdBQW1CLEVBQ25CLFVBQTRFO1FBRTVFLE1BQU0sYUFBYSxHQUFHLFVBQVUsQ0FBQyxLQUFpQixDQUFBO1FBQ2xELElBQUksUUFBUSxHQUFXLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtRQUV4Qyx5QkFDSyxVQUFVLElBQ2IsS0FBSyxFQUFFO2dCQUNMLE1BQU0sR0FBRyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtnQkFFN0IsSUFBSSxHQUFHLEdBQUcsUUFBUSxHQUFHLFFBQVEsRUFBRTtvQkFDN0IsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQTtpQkFDeEQ7Z0JBRUQsUUFBUSxHQUFHLEdBQUcsQ0FBQTtnQkFDZCxPQUFPLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFBO1lBQzdDLENBQUMsSUFDRjtJQUNILENBQUMsQ0FBQTtBQUNILENBQUM7QUFFRCxNQUFNLG1CQUFzQixTQUFpQixFQUFFLFdBQW1CLEdBQUc7SUFDbkUsT0FBTyxVQUNMLE1BQVMsRUFDVCxXQUFtQixFQUNuQixVQUE0RTtRQUU1RSxNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsS0FBaUIsQ0FBQTtRQUNsRCxJQUFJLFFBQVEsR0FBVyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUE7UUFDeEMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFBO1FBRWIseUJBQ0ssVUFBVSxJQUNiLEtBQUssRUFBRTtnQkFDTCxNQUFNLEdBQUcsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUE7Z0JBRTdCLElBQUksR0FBRyxHQUFHLFFBQVEsSUFBSSxRQUFRLEVBQUU7b0JBQzlCLEtBQUssR0FBRyxDQUFDLENBQUE7b0JBQ1QsUUFBUSxHQUFHLEdBQUcsQ0FBQTtpQkFDZjtnQkFFRCxJQUFJLEtBQUssSUFBSSxTQUFTLEVBQUU7b0JBQ3RCLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDLENBQUE7aUJBQ3ZFO2dCQUVELEtBQUssRUFBRSxDQUFBO2dCQUVQLE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUE7WUFDN0MsQ0FBQyxJQUNGO0lBQ0gsQ0FBQyxDQUFBO0FBQ0gsQ0FBQztBQWdERCxNQUFNO0lBR0osWUFBc0IsT0FBbUI7UUFBbkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUN2QyxLQUFLLElBQUksVUFBVSxJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzlDLE1BQU0sU0FBUyxHQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQTtZQUN2QyxJQUFJLE9BQU8sU0FBUyxLQUFLLFVBQVUsRUFBRTtnQkFDbkMsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUU7b0JBQ2xDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7aUJBQ3REO2FBQ0Y7U0FDRjtJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQW1CLEVBQUUsT0FBbUI7UUFDckQsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUMxQixDQUFDOztBQWZNLFVBQU0sR0FBRyxZQUFZLENBQUE7QUFrQjlCLE1BQU0sc0JBQWdDLFNBQVEsR0FBRztDQUVoRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHA6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vY29tcG9uZW50Lmh0bWxcblxuLy8gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG5jb25zdCBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3JcblxuY29uc3QgZXhwb3NlZE1ldGhvZFN5bWJvbCA9IGhhc1N5bWJvbCA/IFN5bWJvbCgnZXhwb3NlZE1ldGhvZCcpIDogMHhmZWExXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvc2VNZXRob2Q8VCBleHRlbmRzIEFQST4oXG4gIHRhcmdldDogVCxcbiAgcHJvcGVydHlLZXk6IGtleW9mIFQsXG4gIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPEV4cG9zYWJsZU1ldGhvZD5cbikge1xuICBnZXRFeHBvc2VkTWV0aG9kcyh0YXJnZXQpLmFkZChwcm9wZXJ0eUtleSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4cG9zZWRNZXRob2RzPFQgZXh0ZW5kcyBBUEk+KGluc3RhbmNlOiBUKTogU2V0PGtleW9mIFQ+IHtcbiAgY29uc3QgaW5zdGFuY2VBbnk6IGFueSA9IGluc3RhbmNlXG4gIGluc3RhbmNlQW55W2V4cG9zZWRNZXRob2RTeW1ib2xdID0gaW5zdGFuY2VBbnlbZXhwb3NlZE1ldGhvZFN5bWJvbF0gfHwgbmV3IFNldCgpXG4gIHJldHVybiBpbnN0YW5jZUFueVtleHBvc2VkTWV0aG9kU3ltYm9sXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmF0ZUxpbWl0PFQ+KGludGVydmFsOiBudW1iZXIgPSAxMDApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKFxuICAgIHRhcmdldDogVCxcbiAgICBwcm9wZXJ0eUtleTogc3RyaW5nLFxuICAgIGRlc2NyaXB0b3I6IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPCguLi5hcmdzOiBhbnlbXSkgPT4gUHJvbWlzZTxhbnkgfCB2b2lkPj5cbiAgKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IGRlc2NyaXB0b3IudmFsdWUgYXMgRnVuY3Rpb25cbiAgICBsZXQgbGFzdENhbGw6IG51bWJlciA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVzY3JpcHRvcixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbih0aGlzOiBUKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICAgICAgaWYgKG5vdyAtIGxhc3RDYWxsIDwgaW50ZXJ2YWwpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdSYXRlIGxpbWl0IGV4Y2VlZGVkJykpXG4gICAgICAgIH1cblxuICAgICAgICBsYXN0Q2FsbCA9IG5vd1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZTxUPihjYWxsTGltaXQ6IG51bWJlciwgaW50ZXJ2YWw6IG51bWJlciA9IDEwMCkge1xuICByZXR1cm4gZnVuY3Rpb24oXG4gICAgdGFyZ2V0OiBULFxuICAgIHByb3BlcnR5S2V5OiBzdHJpbmcsXG4gICAgZGVzY3JpcHRvcjogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8KC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueSB8IHZvaWQ+PlxuICApIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gZGVzY3JpcHRvci52YWx1ZSBhcyBGdW5jdGlvblxuICAgIGxldCBpbml0VGltZTogbnVtYmVyID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBsZXQgY2FsbHMgPSAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVzY3JpcHRvcixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbih0aGlzOiBUKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICAgICAgaWYgKG5vdyAtIGluaXRUaW1lID49IGludGVydmFsKSB7XG4gICAgICAgICAgY2FsbHMgPSAwXG4gICAgICAgICAgaW5pdFRpbWUgPSBub3dcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWxscyA+PSBjYWxsTGltaXQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaHJvdHRsaW5nIOKAkyBNYXhpbXVtIHJhdGUgZXhjZWVkZWQnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxzKytcblxuICAgICAgICByZXR1cm4gb3JpZ2luYWxWYWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIEFQSU9wdGlvbnMgPSB7XG4gIGFwaU5hbWU6IHN0cmluZ1xuICBzeXN0ZW06IGFueVxuICBvbihldmVudDogc3RyaW5nLCBoYW5kbGVyOiA8QSwgTyBleHRlbmRzIG9iamVjdD4ocGFyYW1zOiBBcnJheTxBPiB8IE8pID0+IHZvaWQpOiB2b2lkXG4gIG5vdGlmeShldmVudDogc3RyaW5nLCBwYXJhbXM/OiBPYmplY3QgfCBBcnJheTxhbnk+KTogdm9pZFxuICBleHBvc2UoZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogPEEsIE8gZXh0ZW5kcyBvYmplY3Q+KHBhcmFtczogQXJyYXk8QT4gfCBPKSA9PiBQcm9taXNlPGFueT4pOiB2b2lkXG4gIGdldEFQSUluc3RhbmNlPFg+KGNvbXBvbmVudDogeyBuZXcgKG9wdGlvbnM6IEFQSU9wdGlvbnMpOiBYIH0pOiBYXG4gIGdldEFQSUluc3RhbmNlKG5hbWU6IHN0cmluZyk6IEFQSSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgQVBJQ2xhc3M8VD4gPSB7XG4gIG5ldyAob3B0aW9uczogQVBJT3B0aW9ucyk6IFRcbn1cblxuZXhwb3J0IHR5cGUgRXhwb3NhYmxlTWV0aG9kID0gKC4uLmFyZ3M6IGFueVtdKSA9PiBQcm9taXNlPGFueT5cblxuLy8gd2UgdXNlIGFuIGludGVyZmFjZSBoZXJlIGJlY2F1c2UgaXQgaXMgbWVyZ2FibGUgd2l0aCB0aGUgY2xhc3NcbmV4cG9ydCBpbnRlcmZhY2UgQVBJIHtcbiAgYXBpRGlkTW91bnQ/KCk6IFByb21pc2U8dm9pZD4gfCB2b2lkXG4gIGFwaVdpbGxVbm1vdW50PygpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZFxufVxuXG4vKipcbiAqIFRoaXMgcGF0dGVybiBiZWFycyByZXNlbWJsYW5jZSB0byB0aGUgR2FuZyBvZiBGb3Vy4oCZcyBTdHJhdGVneSBwYXR0ZXJuLlxuICogQm90aCBwYXR0ZXJucyBhcmUgYWJvdXQgdGFraW5nIHBhcnQgb2YgYW4gb2JqZWN04oCZcyBiZWhhdmlvciBhbmQgZGVsZWdhdGluZ1xuICogaXQgdG8gYSBzZXBhcmF0ZSBzdWJvcmRpbmF0ZSBvYmplY3QuIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2l0aCB0aGUgU3RyYXRlZ3lcbiAqIHBhdHRlcm4sIHRoZSBzZXBhcmF0ZSDigJxzdHJhdGVneeKAnSBvYmplY3QgaXMgdXN1YWxseSBzdGF0ZWxlc3PigJRpdCBlbmNhcHN1bGF0ZXNcbiAqIGFuIGFsZ29yaXRobSwgYnV0IG5vIGRhdGEuIEl0IGRlZmluZXMgaG93IGFuIG9iamVjdCBiZWhhdmVzLCBidXQgbm90IHdoYXQgaXQgaXMuXG4gKlxuICogaHR0cDovL3dpa2kuYzIuY29tLz9TdHJhdGVneVBhdHRlcm5cbiAqXG4gKiBDb21wb25lbnRzIGFyZSBhIGJpdCBtb3JlIHNlbGYtaW1wb3J0YW50LiBUaGV5IG9mdGVuIGhvbGQgc3RhdGUgdGhhdCBkZXNjcmliZXNcbiAqIHRoZSBvYmplY3QgYW5kIGhlbHBzIGRlZmluZSBpdHMgYWN0dWFsIGlkZW50aXR5LiBIb3dldmVyLCB0aGUgbGluZSBtYXkgYmx1ci5cbiAqIFlvdSBtYXkgaGF2ZSBzb21lIGNvbXBvbmVudHMgdGhhdCBkb27igJl0IG5lZWQgYW55IGxvY2FsIHN0YXRlLiBJbiB0aGF0IGNhc2UsXG4gKiB5b3XigJlyZSBmcmVlIHRvIHVzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgYWNyb3NzIG11bHRpcGxlIGNvbnRhaW5lciBvYmplY3RzLlxuICogQXQgdGhhdCBwb2ludCwgaXQgcmVhbGx5IGlzIGJlaGF2aW5nIG1vcmUgYWtpbiB0byBhIHN0cmF0ZWd5LlxuICpcbiAqIENvbXBvbmVudHMgYXJlIGxvY2F0ZWQgdmlhIHNlcnZpY2UgbG9jYXRvcnMgbWFuYWdlZCBieSB0aGUgQ29tcG9uZW50U3lzdGVtXG4gKlxuICogQSBDb21wb25lbnRzIGNsYXNzIGRlZmluZXMgYW4gYWJzdHJhY3QgaW50ZXJmYWNlIHRvIGEgc2V0IG9mIG9wZXJhdGlvbnMuXG4gKiBUaGF0IGludGVyZmFjZSBpcyBleHBvc2VkIHZpYSBAZXhwb3NlTWV0aG9kIGRlY29yYXRvci4gQSBjb25jcmV0ZSBzZXJ2aWNlXG4gKiBwcm92aWRlciBpbXBsZW1lbnRzIHRoaXMgaW50ZXJmYWNlLiBBIHNlcGFyYXRlIHNlcnZpY2UgbG9jYXRvciAoQ29tcG9uZW50U3lzdGVtKVxuICogcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBzZXJ2aWNlIGJ5IGZpbmRpbmcgYW4gYXBwcm9wcmlhdGUgcHJvdmlkZXIgd2hpbGUgaGlkaW5nXG4gKiBib3RoIHRoZSBwcm92aWRlcuKAmXMgY29uY3JldGUgdHlwZSBhbmQgaW1wbGVtZW50YXRpb24gYW5kIHRoZSBwcm9jZXNzIHVzZWQgdG9cbiAqIGxvY2F0ZSBpdC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFQSSB7XG4gIHN0YXRpYyBleHBvc2UgPSBleHBvc2VNZXRob2RcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgb3B0aW9uczogQVBJT3B0aW9ucykge1xuICAgIGZvciAobGV0IG1ldGhvZE5hbWUgb2YgZ2V0RXhwb3NlZE1ldGhvZHModGhpcykpIHtcbiAgICAgIGNvbnN0IHRoZU1ldGhvZDogYW55ID0gdGhpc1ttZXRob2ROYW1lXVxuICAgICAgaWYgKHR5cGVvZiB0aGVNZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2ROYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5leHBvc2UobWV0aG9kTmFtZSwgdGhlTWV0aG9kLmJpbmQodGhpcykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZmFjdG9yeShjdG9yOiBBUElDbGFzczxBUEk+LCBvcHRpb25zOiBBUElPcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBjdG9yKG9wdGlvbnMpXG4gIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN1YnNjcmliYWJsZUFQSSBleHRlbmRzIEFQSSB7XG4gIGFic3RyYWN0IGFzeW5jIHN1YnNjcmliZShldmVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTdWJzY3JpYmFibGVBUEkge1xuICBzdWJzY3JpYmUoZXZlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbiAgdW5zdWJzY3JpYmUoZXZlbnQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbiAgb25TdWJzY3JpYmVkRXZlbnQoZm46IChkYXRhOiBhbnkpID0+IHZvaWQpOiB2b2lkXG59XG4iXX0=